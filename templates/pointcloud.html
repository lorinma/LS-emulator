<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive - raycasting - pointcloud</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;

				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			a {
				color: #fff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
        <script type="text/javascript" src="{{ url_for('static', filename='') }}three.min.js"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='') }}Detector.js"></script>
        <script type="text/javascript" src="{{ url_for('static', filename='') }}stats.min.js"></script>
		<script>

        if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

        var renderer, scene, camera, stats;
        var pointclouds;
        var raycaster, intersects;
        var mouse = new THREE.Vector2();
        var intersection = null;
        var spheres = [];
        var spheresIndex = 0;
        var clock;
        var centroid = [];


        var threshold = 0.1;
        var scale=[100,100,100]
        var pointSize = 1;
        var width = 150;
        var length = 150;
        var rotateY = new THREE.Matrix4().makeRotationY( 0.005 );

        init();
        animate();

        function readFile(file){
            var rawFile = new XMLHttpRequest();
            var content = '';
            rawFile.open("GET", file, false);
            rawFile.onreadystatechange = function (){
                if(rawFile.readyState === 4){
                    if(rawFile.status === 200 || rawFile.status == 0){
                        content = rawFile.responseText;
                    }
                }
            }
            rawFile.send(null);
            return content;
        }

        function pointCount(data){
            var patternWidth = /WIDTH([\s\S]*)HEIGHT\s/;
            var patternHeight = /HEIGHT([\s\S]*)VIEWPOINT\s/;
            var width = 1;
            var height = 1;
            if ( ( result = patternWidth.exec( data ) ) !== null ) {
                width = parseInt(result [ 1 ]);
            }
            if ( ( result = patternHeight.exec( data ) ) !== null ) {
                height = parseInt(result [ 1 ]);
            }
            return width*height;
        }

        function getPoint(line){
            var values = line.split(/\s+/);
            var point = { x: parseFloat(values[0]), y: parseFloat(values[1]),
                z: parseFloat(values[2])};
            return point;
        }

        function loadPoints(data,count){
            var lines = data.split( '\n' );
            var positions = new Float32Array( count*3 );
            var color = new THREE.Color(0,0,0);
            var colors = new Float32Array (count *3);
            var lineCount = lines.length;
            var k = 0;
            var x = 0.0;
            var y = 0.0;
            var z = 0.0;
            lineCount = 4;
            for( var i = 0; i < lineCount; i++){
                var line = lines[ i ];
                line = line.trim()
                if ( line === "" ) { continue; }

                var point = getPoint(line);
                positions[ 3 * k] = point.x;
                positions[ 3 * k + 1] = point.y;
                positions[ 3 * k + 2] = point.z;

                colors[ 3 * k] = color.r;
                colors[ 3 * k + 1] = color.g;
                colors[ 3 * k + 2] = color.b;

                x += point.x;
                y += point.y;
                z += point.z;

                k++ ;
                if(k>=count){break;}
            }
            //centroid = [-x/k, -y/k, -z/k];
            //centroid = [x/k, y/k, z/k];
            centroid = [0,0,0];
            var buff = new THREE.BufferGeometry();
            buff.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            buff.addAttribute( 'color', new THREE.BufferAttribute( colors , 3 ) );
            buff.computeBoundingBox();
            return buff;
        }

        function loadGeometry(file){
            var data = readFile(file);
            var count = pointCount(data);
            var patternBody = /ascii\s([\s\S]*)$/;
            var body = "";
            if ( ( result = patternBody.exec( data ) ) !== null ) {
                body = result [ 1 ];
            }
            return loadPoints(body,count);
        }
        function genPCD(file) {
            var geometry = loadGeometry(file);
            var material = new THREE.PointCloudMaterial( { size: pointSize, vertexColors: THREE.VertexColors } );
            var pointcloud = new THREE.PointCloud( geometry, material );

            return pointcloud;

        }
        function init() {
            container = document.getElementById( 'container' );

            scene = new THREE.Scene();

            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.applyMatrix( new THREE.Matrix4().makeTranslation( 0,0,20 ) );
            camera.applyMatrix( new THREE.Matrix4().makeRotationX( -0.5 ) );
            /*
            */
            var pcBuffer = genPCD("{{ url_for('static', filename='') }}{{ fid }}.pcd");
            //pcBuffer.scale.set( 10,10,10 );
            pcBuffer.scale.set(scale[0],scale[1],scale[2]);
            //pcBuffer.position.set( -5,0,5 );
            //pcBuffer.position.set(centroid[0],centroid[1],centroid[2]);
            scene.add( pcBuffer );
            //camera.applyMatrix( new THREE.Matrix4().makeTranslation(centroid[0],centroid[1],centroid[2]));
            camera.applyMatrix( new THREE.Matrix4().makeTranslation(centroid[0],centroid[1],centroid[2]));
            //alert(centroid);
            //camera.position.x = centroid[0];
            //camera.position.y = centroid[1];
            //camera.position.z = centroid[2]+100;

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor( 0xffffff, 1);
            container.appendChild( renderer.domElement );

            //raycaster = new THREE.Raycaster();

            //raycaster.params.PointCloud.threshold = threshold;

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            container.appendChild( stats.domElement );

            window.addEventListener( 'resize', onWindowResize, false );
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        }

        function onDocumentMouseMove( event ) {

            event.preventDefault();

            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            //requestAnimationFrame( animate );

            render();
            stats.update();

        }

        var toggle = 0;

        function render() {

            camera.applyMatrix( rotateY );
            camera.updateMatrixWorld();

            //raycaster.setFromCamera( mouse, camera );

            //var intersections = raycaster.intersectObjects( pointclouds );
            //intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
/*
            if ( toggle > 0.02 && intersection !== null) {

                spheres[ spheresIndex ].position.copy( intersection.point );
                spheres[ spheresIndex ].scale.set( 1, 1, 1 );
                spheresIndex = ( spheresIndex + 1 ) % spheres.length;

                toggle = 0;

            }
            for ( var i = 0; i < spheres.length; i++ ) {

                var sphere = spheres[ i ];
                sphere.scale.multiplyScalar( 0.98 );
                sphere.scale.clampScalar( 0.01, 1 );

            }

            toggle += clock.getDelta();
*/

            renderer.render( scene, camera );

        }

		</script>

	</body>

</html>
